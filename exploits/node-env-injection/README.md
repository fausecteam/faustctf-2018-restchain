Node.js Environment Injection
=============================

Carlessly passing environment variables to Node.js allows arbitrary code
execution.

Bug
---

The `EvaluateACL` function passes the block and HTTP headers to Node.js as
environment variables. While the variables coming from HTTP headers are
prefixed with `HTTP_`, the `X-Restchain-Block-*` headers stored in the block
itself are stripped from this prefix and passed as is, allowing arbitrary
environment variables to be set for Node.js.

Exploit
-------

The first idea is to set `LD_PRELOAD` and get code execution this way, while in
theory possible, I am not aware of a practical way to exploit this, unless some
other service allows placing files with arbitrary content and predictable names
which are readable by the `restchain` user (if there's a way, that's fine
though). RESTchain itself does not provide such a mechanism and to my
knowledge, one can't use the block files as they start with HTTP headers in the
beginning where ELF requires a fixed header.

The second idea is to change the behavior of Node.js by passing some
environment variables. For example, `NODE_OPTIONS` allows passing options as if
they were supplied to the command line, however there is a whitelist in place
and options like `--eval` do not work. But `--require`/`-r` is allowed, which
in combination with `NODE_PATH` allows loading javascript from an arbitrary
file, which you still have to place somewhere. One possibiliy for this is to
use `/proc/self/environ` for this and pass a variable so that the file starts
with `SOMETHING=console.log('got code execution');//` which happens to be valid
Javascript. The behavior can be observed using the following command:

```
env -i X='console.log("got code execution");//' NODE_PATH=/proc/self NODE_OPTIONS='--require environ' /usr/bin/node
```

Luckily, when evaluating ACLs, RESTchain starts from a clean environment, adds
the HTTP headers, and then the block headers, so one can pass the code as a
HTTP header (or as a block header if one manages to send no headers at all). Go
randomized the order of map entries, so the order of environment variables is
not fully deterministic, so maybe an exploit takes a few attempts.

There may also be other ways to exploit this, if you find any, I'd like to hear
about it.

Patch
-----

Adding an additional prefix to the block environment variables should do the
trick.  To prevent the exact exploit described above, simply adding some dummy
variable first is enough, however there may be other ways to exploit this. To
be completely sure, one could also pass everything as JSON.
