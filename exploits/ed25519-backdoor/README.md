Ed25519 Backdoor
================

The shipped `ed25519.go` file is based on
[golang.org/x/crypto/ed25519](https://godoc.org/golang.org/x/crypto/ed25519)
but includes a tiny little backdoor with catastrophic consequences on the
confidentiality of the private key used to generate a signature using the
modified library.

Bug
---

Similar to DSA and ECDSA, EdDSA relies on an unpredictable number being used in
the signature generation. In case of Ed25519, the private key $`k`$ is a random
32 byte string which is then stretched to 64 bytes using SHA512 and split into
two halves: $`k_1 || k_2 = \mathrm{SHA512}(k)`$. $`k_1`$ is then used as the
actual secret key (called $`s`$ in the [Wikipedia
article](https://en.wikipedia.org/w/index.php?oldid=830254412)) and $`k_2`$ is
used as a seed to generate the unpredictable number $`r = \mathrm{SHA512}(k_2,
message)`$. The backdoored implementation used the public key instead of the
$`k_2`$ to generate $`r`$, which is possible with only a tiny change in the Go
code as the implementation stores $`k || pub`$ in its internal private key
representation so the code is only changed to use `private[32:]` instead of
`SHA512(private[:32])[32:]` which effectively means only changing a single
variable name in the code.

Exploit
-------

Once we see a signature and know the corresponding message (which is a hash in
RESTchain which is published together with the signature so that the original
message does not have to be known), we can compute $`r`$. Following the
Wikipedia notation, we can compute $`s = (S_{sig} - r) \cdot
\mathrm{SHA512}(R_{sig} || publickey || message)^{-1} \pmod l`$ where
$`R_{sig}`$ and $`S_{sig}`$ are the two halves of the signature ($`S_{sig}`$ is
an integer and $`R_{sig}`$ is the binary encoding of a curve point). This $`s`$
can then be used to generate a signature for the new message $`fake`$:
$`S_{fake} = r + \mathrm{SHA512}(R_{sig} || publickey || fake) \cdot d \pmod
l`$. The full signature can then be obtained by concatenating $`R_{sig}`$ and
$`S_{fake}`$. As a bonus, als these operations are done in
$`\mathbb{Z}/l\mathbb{Z}`$, where $`l`$ is just some constant from Ed25519.

The exploit obtains a block protected with the `require-signature` ACL by
getting the signature, faking an access signature from the same key using the
method described above and then accesses the block using this signature.

Patch
-----

Either replace the single variable in the provided source code (look for `OOPS`
in the version still containing comments) or swap the ed25519 implementation
(the signatures from the broken version are still fully compatible with the
original version, but the API has been modified slightly so that some
additional work is needed).
